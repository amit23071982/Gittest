jq -r '.prefixes[] | select(.region=="eu-west-1") |
select(.service=="EC2") | .ip_prefix' < ip-ranges.json

VPC
 az1
 public-subnet-1
private-subnet-1


 az2
 public-subnet-2
private-subnet-2
 az3
 public-subnet-3
private-subnet-3
IGW
Route table
 Public-subnet-1 : igw
 Public-subnet-2 : igw
 Public-subnet-3 : igw

securitygroup.tf
 1 sg
 incomming 22 for all
outgoing for all port
key.tf
 will ceate keypair with name - mykeypair

instance.tf
 EBS voulme of 20 GB
 create 1 VM
 User datas
 init.cfg
 yum update -y
 yum upgrdae -y
 yum install lvm
volume.sh
 is fs loaded
 pv create
 vg create
 lv create
 mount filesystem
 install docker





 Changes(on terraform machine in directory demo-10)
 1. VPC.tf - based on you region select az
 2. key.tf - ssh-keygen -f mykeypair
 3. vars.tf - your region, ami id (linux)
 4. instance.tf (ebs volume creation) select az1 (use public-subnet1)
 5. terrfaorm init
 6. terraform plan
 7. terrafom apply

 at the end or if you get error
 terraform destroy
====Terraform Plan=====
An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
 + create
Terraform will perform the following actions:
 # aws_ebs_volume.ebs-volume-1 will be created
 + resource "aws_ebs_volume" "ebs-volume-1" {
 + arn = (known after apply)
 + availability_zone = "us-east-2a"
 + encrypted = (known after apply)
 + id = (known after apply)
 + iops = (known after apply)
 + kms_key_id = (known after apply)
 + size = 20
 + snapshot_id = (known after apply)
 + tags = {
 + "Name" = "extra volume data"
 }
 + type = "gp2"
 }
 # aws_instance.example will be created
 + resource "aws_instance" "example" {
 + ami = "ami-0520e698dd500b1d1"
 + arn = (known after apply)
 + associate_public_ip_address = (known after apply)
 + availability_zone = (known after apply)
 + cpu_core_count = (known after apply)
 + cpu_threads_per_core = (known after apply)
 + get_password_data = false
 + host_id = (known after apply)
 + id = (known after apply)
 + instance_state = (known after apply)
 + instance_type = "t2.micro"
 + ipv6_address_count = (known after apply)
 + ipv6_addresses = (known after apply)
 + key_name = "demo10keypair"
 + network_interface_id = (known after apply)
 + password_data = (known after apply)
 + placement_group = (known after apply)
 + primary_network_interface_id = (known after apply)
 + private_dns = (known after apply)
 + private_ip = (known after apply)
 + public_dns = (known after apply)
 + public_ip = (known after apply)
 + security_groups = (known after apply)
 + source_dest_check = true
 + subnet_id = (known after apply)
 + tenancy = (known after apply)
 + user_data =
"10b2bac2e22759d128c78b16ef5f7c5505113fc8"
 + volume_tags = (known after apply)
 + vpc_security_group_ids = (known after apply)
 + ebs_block_device {
 + delete_on_termination = (known after apply)
 + device_name = (known after apply)
 + encrypted = (known after apply)
 + iops = (known after apply)
 + kms_key_id = (known after apply)
 + snapshot_id = (known after apply)
 + volume_id = (known after apply)
 + volume_size = (known after apply)
 + volume_type = (known after apply)
 }
 + ephemeral_block_device {
 + device_name = (known after apply)
 + no_device = (known after apply)
 + virtual_name = (known after apply)
 }
 + metadata_options {
 + http_endpoint = (known after apply)
 + http_put_response_hop_limit = (known after apply)
 + http_tokens = (known after apply)
 }
 + network_interface {
 + delete_on_termination = (known after apply)
 + device_index = (known after apply)
 + network_interface_id = (known after apply)
 }
 + root_block_device {
 + delete_on_termination = (known after apply)
 + encrypted = (known after apply)
 + iops = (known after apply)
 + kms_key_id = (known after apply)
 + volume_id = (known after apply)
 + volume_size = (known after apply)
 + volume_type = (known after apply)
 }
 }
 # aws_internet_gateway.main-gw will be created
 + resource "aws_internet_gateway" "main-gw" {
 + id = (known after apply)
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main"
 }
 + vpc_id = (known after apply)
 }
 # aws_key_pair.demo10keypair will be created
 + resource "aws_key_pair" "demo10keypair" {
 + fingerprint = (known after apply)
 + id = (known after apply)
 + key_name = "demo10keypair"
 + key_pair_id = (known after apply)
 + public_key = "ssh-rsa
AAAAB3NzaC1yc2EAAAADAQABAAABgQDTgfinKgORW43dsBfwavqWU1eeuZAco4S8Xjm4O8
rXHqdGaevwiBSx07VIzpwP9Li6Th4NBtrcCk9z+LkORpV2i87n57ZfcStb13WxFgQkDB6o
pZLt+F5+BTV7TujDbn5VYtT4blqWmGmOtryAbm6DYgs4PH5RG0giHTYXJNjn/qypZvNL1B
Esgz8ab8RhLZkVf/Nar+MZHSCFh8h4qoay1p6+WiyHYnIRkVkKzxSoi/mDuIVpAODv4P1F
VpE9AcbJWQ6zsmbR8o2722eC6vq9lhrMXnm3LepbefYDbG1+QgUpZCFF7NzeSzc9Z3GWEC
6BDV2JKIQ6E0FmaqpOw9mPUlHVf/pyDd6FD5h9rpT+tv9FLlBMWSe+ZgIihr/eqgXYFNk5
Rpy5TZl/eCeQWEKiBnQYcNCBalKSvOqHlqLmfqrfFGJOU74sJufm1BhsYhx4Yl3INIad9u
hWzNYHkpwNAfpGBkXnB0Wn4LmjwH7cxDP16ZxIojwEJSfSMB0vxxc= root@ip-172-31-
23-177.us-east-2.compute.internal"
 }
 # aws_route_table.main-public will be created
 + resource "aws_route_table" "main-public" {
 + id = (known after apply)
 + owner_id = (known after apply)
 + propagating_vgws = (known after apply)
 + route = [
 + {
 + cidr_block = "0.0.0.0/0"
 + egress_only_gateway_id = ""
 + gateway_id = (known after apply)
 + instance_id = ""
 + ipv6_cidr_block = ""
 + nat_gateway_id = ""
 + network_interface_id = ""
 + transit_gateway_id = ""
 + vpc_peering_connection_id = ""
 },
 ]
 + tags = {
 + "Name" = "main-public-1"
 }
 + vpc_id = (known after apply)
 }
 # aws_route_table_association.main-public-1-a will be created
 + resource "aws_route_table_association" "main-public-1-a" {
 + id = (known after apply)
 + route_table_id = (known after apply)
 + subnet_id = (known after apply)
 }
 # aws_route_table_association.main-public-2-a will be created
 + resource "aws_route_table_association" "main-public-2-a" {
 + id = (known after apply)
 + route_table_id = (known after apply)
 + subnet_id = (known after apply)
 }
 # aws_route_table_association.main-public-3-a will be created
 + resource "aws_route_table_association" "main-public-3-a" {
 + id = (known after apply)
 + route_table_id = (known after apply)
 + subnet_id = (known after apply)
 }
 # aws_security_group.allow-ssh will be created
 + resource "aws_security_group" "allow-ssh" {
 + arn = (known after apply)
 + description = "security group that allows ssh and
all egress traffic"
 + egress = [
 + {
 + cidr_blocks = [
 + "0.0.0.0/0",
 ]
 + description = ""
 + from_port = 0
 + ipv6_cidr_blocks = []
 + prefix_list_ids = []
 + protocol = "-1"
 + security_groups = []
 + self = false
 + to_port = 0
 },
 ]
 + id = (known after apply)
 + ingress = [
 + {
 + cidr_blocks = [
 + "0.0.0.0/0",
 ]
 + description = ""
 + from_port = 22
 + ipv6_cidr_blocks = []
 + prefix_list_ids = []
 + protocol = "tcp"
 + security_groups = []
 + self = false
 + to_port = 22
 },
 ]
 + name = "allow-ssh"
 + owner_id = (known after apply)
 + revoke_rules_on_delete = false
 + tags = {
 + "Name" = "allow-ssh"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-private-1 will be created
 + resource "aws_subnet" "main-private-1" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2a"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.4.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = false
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-private-1"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-private-2 will be created
 + resource "aws_subnet" "main-private-2" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2b"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.5.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = false
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-private-2"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-private-3 will be created
 + resource "aws_subnet" "main-private-3" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2c"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.6.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = false
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-private-3"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-public-1 will be created
 + resource "aws_subnet" "main-public-1" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2a"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.1.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = true
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-public-1"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-public-2 will be created
 + resource "aws_subnet" "main-public-2" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2b"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.2.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = true
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-public-2"
 }
 + vpc_id = (known after apply)
 }
 # aws_subnet.main-public-3 will be created
 + resource "aws_subnet" "main-public-3" {
 + arn = (known after apply)
 + assign_ipv6_address_on_creation = false
 + availability_zone = "us-east-2c"
 + availability_zone_id = (known after apply)
 + cidr_block = "10.0.3.0/24"
 + id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + ipv6_cidr_block_association_id = (known after apply)
 + map_public_ip_on_launch = true
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main-public-3"
 }
 + vpc_id = (known after apply)
 }
 # aws_volume_attachment.ebs-volume-1-attachment will be created
 + resource "aws_volume_attachment" "ebs-volume-1-attachment" {
 + device_name = "/dev/xvdh"
 + id = (known after apply)
 + instance_id = (known after apply)
 + volume_id = (known after apply)
 }
 # aws_vpc.main will be created
 + resource "aws_vpc" "main" {
 + arn = (known after apply)
 + assign_generated_ipv6_cidr_block = false
 + cidr_block = "10.0.0.0/16"
 + default_network_acl_id = (known after apply)
 + default_route_table_id = (known after apply)
 + default_security_group_id = (known after apply)
 + dhcp_options_id = (known after apply)
 + enable_classiclink = false
 + enable_classiclink_dns_support = (known after apply)
 + enable_dns_hostnames = true
 + enable_dns_support = true
 + id = (known after apply)
 + instance_tenancy = "default"
 + ipv6_association_id = (known after apply)
 + ipv6_cidr_block = (known after apply)
 + main_route_table_id = (known after apply)
 + owner_id = (known after apply)
 + tags = {
 + "Name" = "main"
 }
 }
Plan: 17 to add, 0 to change, 0 to destroy.
----------------------------------------------------------------------
--
Note: You didn't specify an "-out" parameter to save this plan, so
Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.